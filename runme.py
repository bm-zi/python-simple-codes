#!/usr/bin/python3
# Author: bm-zi

import functions, os, time, sys, re

'''
Functions bookmarks:
--------------------
def help():
def restart():
def lineCount(fileName):
def lastItem():
def exitProg():
def resetScreen():
def highlight(text):
def current_time():
def logo():
def edit_function(item):
def view_function(function_number):
def search_in_files(response):
def view_code(i):
def run_code(i):
def rolling_list():
    def listdisplay(start_line, chunk):
    def listdisplayrev(start_line, chunk):
    def runnerRev(stln):
    def runner(stln):
'''

file_list = os.path.abspath('list')
file_functions = os.path.abspath('functions.py')

def help():
    resetScreen()
    help = '''
    ..............................................................
    |||||||||||||||||||||||| HELP MANUAL |||||||||||||||||||||||||
    ..............................................................
    The prompts for browsing in main menu looks like as following:
    Search > 
    
    While using the prompt for entering a command or  a character, 
    you need to click on 'Enter key.
    This program is not using one-touch character method for runn-
    ing pre-defined commands.

    Note: Except of defined keys or combination  of keys explained 
    in following help guid, you can enter any other pattern at the 
    search prompt to get a result after searching in browsing list
    or in the body of the respective function f[number], from file 
    functions.py
   
    ..............................................................
    ||||||||||||| Keys defined for Search prompt |||||||||||||||||
    ..............................................................
    Resetting Program:
    From 'Search' prompt you can type any of the following charac-
    ters to reset the program:
    \\ , + , - , / , * , . , Space

    [Enter]
    press 'Enter' continiousely to to navigate through the rolling
    list of items, it will will roll the browsing list in ascendi-
    ng order.

    [number]
    if you type any numbers in search prompt, it  will opens the -
    list from that item number. 

    'f' + [number]
    If try this format(for example f45, f67 or 204), then the con-
    tent of the respective functions will be displayed, fetching -
    the content of the function from the file functions.py

    'e' + [number]
    If try this format(for example e45, e67 or e204), then  the vi 
    editor will be opened at the line containing function name.
    For example vi opens function f45, f67 or f204 from the file - 
    functions.py

    'x' + [number]
    This combination will run the function number [number], like:
    x14 ,x235 or x112

    'r'
    FORWARD PARSING of items in the main list can be switched over
    to BACKWARD PARSING, by typing 'r'. While  the reverse parsing
    reaches to the last item (item number 1), then it changes back 
    to forward parsing automatically.
    In forward parsing, while pasrsing the list elements reaches -
    to the end, then program will return to initial screen.

    'f'
    By default, parsing the main list of items is in ascending or-
    der of item numbers. You can changed the parsing anytime while 
    you are in REVERSE PARSING mode, by typing 'f'.

    'openlist'
    Using this command at search prompt opens the file list in the
    current directory.

    'runme'
    Entring this command at search prompt opens the file 'runme.py'  
    in the current directory.

    'bookmarks'
    Opens file bookmarks with editer vi
    
    'b'
    Showing content of file bookmarks

    'q'
    To exit the program type 'q' in 'Search' prompt.
    

    ..............................................................
    ||||||||||||||| Other notes in using program |||||||||||||||||
    ..............................................................

    - For many outputs generated by program if the  size of output
      is bigger than terminal size, then for paginating output the 
      unix command "less" has been used, so ouput can  be scrolled 
      up and down or you can search for a pattern, within the out-
      put.


    - You can use the omitNo.py script in current directory to add
      or insert new sample code.
      That means omitNo.py increments the functions number and the 
      numbers in list file, that makes easier for you adding  your 
      sample code to file functions.py and also items in file list 

    '''

    fhand = open('help', 'w')
    fhand.write(help)
    fhand.close()

    os.system('less -i help')
    os.unlink('help')
    resetScreen()

#############
def chgdir():
    # print("script: sys.argv[0] is", repr(sys.argv[0]))
    # print("script: __file__ is", repr(__file__))
    # print("script: cwd is", repr(os.getcwd()))

    abspath = os.path.abspath(__file__)
    file_list = abspath + '/list'
    file_functions = abspath + '/functions.py'
    dname = os.path.dirname(abspath)
    os.chdir(dname)

#############
def restart():
    # Restarts the current running script, to initial state
    os.execl(sys.executable, sys.executable, * sys.argv)

#############
def readline(fname, nr):
    nr = nr - 1
    with open(fname) as f:
        for i, line in enumerate(f):
            if i == nr:
                return(line)
        else:
            print('line is not in file')
            line = None

#######################
def lineCount(fileName):
    # Returns number of the lines of a file that is passed as the 
    # argument to this function

    fh = open(fileName)
    
    line_count = 0
    for line in fh: 
        line_count += 1

    fh.close()    
    return line_count

##############
def lastItem():
    return lineCount(file_list)

##############
def exitProg():
    # Removes all files and folders in current working direcctory,
    # except of files runme.py, functions.py and list

    import os, shutil

    folder = '.'  # Current working directory

    for the_file in os.listdir(folder):
        file_path = os.path.join(folder, the_file)
        try:
            if os.path.isfile(file_path) and \
                not file_path == './runme.py' and  \
                not file_path == './list' and  \
                not file_path == './functions.py' and \
                not file_path == './bookmarks' and \
                not file_path == './omitNo.py':
                os.unlink(file_path)
            elif os.path.isdir(file_path) and not file_path == './data': 
                shutil.rmtree(file_path)
        except Exception as e:          # catch *all* exceptions
            print(e)

    resetScreen(); sys.exit()

#################
def resetScreen():
    # Resizes terminal and clears the screen
    print('\x1b[8;42;80t') ; os.system('clear')

###################
def highlight(text):
    # highlighting string argument 'text' in bold characters
    os.system("tput smso"); print(text); os.system("tput rmso")

##################
def current_time():
    return(time.strftime("%B %d, ") + time.strftime("%H:%M"))

##########
def logo():
    # This function prints the program title and introduction

    logo = '''
┌──────────────────────────────────────────────────────────────────────────────┐
│                Welcome to Interactive Python Programming                     │
│   A menu-based tool to preview, edit and launch sample Python 3 programs     │
└──────────────────────────────────────────────────────────────────────────────┘''' 
    highlight(logo)
    print()
    #print(time.strftime("%B %d, ") + time.strftime("%H:%M"))

####################
def edit_function(item):
    os.system('\\vi +/def\ f' + item + ' ' + file_functions)
    restart()

#########################
def view_function(function_number):
    # This function gets the content of the function 
    # f[function_number] from  within file functions.py and prints 
    # out that respective fuction content.

    # In following loop, extract the content between definition of
    # function f(n) and the next following function f(n+1)

    firstline = '     Sample code from function f' + \
        str(function_number) + '\n' + \
                '    ' + '=' * 32 + '\n\n'

    if int(function_number) < lastItem():
            
        infile = open(file_functions)
        outfile = open('temp','w')
            
        copy = False
        for line in infile:
            if line.strip().startswith('def f' 
                + str(function_number) +'():'):
                copy = True
            elif line.strip().startswith('def f' 
                + str(int(function_number)+1) +'():'):
                copy = False
            elif copy:
                outfile.write(line)

        infile.close() ; outfile.close()

        # prepend firstline to temporary output file temp
        open('sample_code', 'w').write( firstline + \
            open('temp', 'r').read())
        resetScreen()
        
        rows = os.popen("tput lines").read().rstrip()
        if lineCount('sample_code') <= int(rows):
            os.system('less +G -i sample_code')
        else:
            os.system('less -i sample_code')

        os.unlink('sample_code')
        os.unlink('temp')

    else:
        input('Out of the range of available functions!' + 
        '\nPress any key to continue .. ')
        restart()

#########################
def search_in_functions(response):

    # Search in file 'functions.py'
    # The goal is to get the all functions that are notified with 
    # f[number] in file functions.py. Then based on the pattern 
    # we search which function has that pattern within its own 
    # body.


    # get the terminal size by bash command and store it in a 
    # Python variable, to repeat printing '|' as terminal width
    width = os.popen("tput cols").read().rstrip()
    print('|' * int(width))

    print('Function   Lines from functions.py, containing:')
    print('Name      \'' + response + '\'')
    print('|' * int(width))

    FH1 = open(file_functions)
    # Create a list of lines starting with pattern 'def'
    lines_start_with_def = list()
    line_numbers_start_with_def = list()
    for nr, line in enumerate(FH1):
        # if re.search('^def', line):
        if line.startswith('def '):
            lines_start_with_def.append(line.rstrip())
            line_numbers_start_with_def.append(nr+1)
    FH1.close()

    FH2 = open(file_functions)
    # Create a list of lines containing pattern 'response'
    lines_contain_match = list()
    line_numbers_contain_match = list()
    for nr, line in enumerate(FH2):
        if re.search(response, line, re.I):
            lines_contain_match.append(line.rstrip())
            line_numbers_contain_match.append(nr+1)
    FH2.close()


    # parsing list line_numbers_contain_match 
    
    result_list_functions = list()
    for nr in line_numbers_contain_match:
        
        for el in reversed(range(nr)):
            if not readline(file_functions, el).startswith('def'): continue
            #print(readline(file_functions, el).split()[1])
            result_list_functions.append(readline(file_functions, el).split()[1])

            break
    if len(result_list_functions) == 0:
        print('No match found!')    
    for i in range(len(result_list_functions)):
        print(result_list_functions[i] + \
            str(lines_contain_match[i]))

#################    
def search_in_list(response):
    # Search in file 'list'
    width = os.popen("tput cols").read().rstrip()
    FH4 = open(file_list)
    print('|' * int(width))
    print('RESULT OF SEARCH IN MAIN LIST FOR \'' + \
        response  + '\' ')
    
    print('|' * int(width))
    match_list = list()
    for line in FH4:
        if re.search(response, line, re.I):
            match_list.append(line.strip())
   
    if len(match_list) == 0:
        print('No match found!')
    else:
        for line in match_list:
            print(line)

    FH4.close()

#################
def search_view(response):

    orig_stdout = sys.stdout
    FH = open('Search', 'w')
    sys.stdout = FH
     
    search_in_functions(response)
    print('\n')
    search_in_list(response)
    print('\n')
    
    sys.stdout = orig_stdout
    FH.close()
    os.system('less +G -i Search') 
#################
def view_code(i):
    flist = open(file_functions).readlines()

    lines = []
    parsing = False
    for line in flist:
        if line.startswith('def f' + str(i + 1) + '()'):
            parsing = False
        if parsing:
            lines.append(line)
        if line.startswith('def f' + str(i) + '()'):
            parsing = True

    return lines


################
def run_code(i):
    num=int(i)
    varstring1 = 'f' + str(num)
    varstring2 = 'f' + str(num + 1)

    resetScreen()
    
    header = '|' * 20 + ' FUNCTION f' + str(num) + \
            ' WILL BE EXECUTED! ' + '|' * 20 + '\n'

    tempFile = open('function_body', 'a')
    tempFile.write(header)
    lines = view_code(num)
    for ln in lines:
        tempFile.write(ln)
    tempFile.close()
    
    resetScreen()
    os.system('less -i function_body')
    tempFile = open('function_body')
    content = tempFile.read()
    tempFile.close()
    print(content)

    confirm = input('Execute? [Enter], Quit? [q] ')
    if confirm == 'q':
        resetScreen()
        os.unlink('function_body')
        return

    os.unlink('function_body')
    footer = '|' * 18 + ' OUTPUT FOR FUNCTION ' + \
        str(num) + ' ' + '|' * 18

    highlight(footer)

    fct=getattr(functions, varstring1)
    fct()
    sep = '|' * 61
    highlight(sep)
    print('Press any key to continue!', end='')
    input()
    resetScreen()
    return

##################
def rolling_list():
    # This function has these nested functions: 
    # listDisplay() and listDisplayrev()
    # runnerRev() and runner() that handle all operation based on 
    # user input in search prompt, having the form of 'Search > '

    def listdisplay(start_line, chunk):
        # This function returns a list of items reading from file 
        # list. The passed arguments, specify how many items will 
        # be displayed, from starting item number(start_line)
        
        start_line = int(start_line) - 1

        arr = []
        with open(file_list) as my_file:
            for line in my_file:
                line = line.strip()
                arr.append(line)

        lines = len(arr)

        try:
            lines = len(arr)
            while chunk > 0 and start_line <= (start_line + 5) \
                and start_line <= lines:
                print(arr[start_line])
                start_line = start_line + 1
                chunk = chunk - 1
        except IndexError:
            return

    def listdisplayrev(start_line, chunk):
        start_line = int(start_line) - 1

        arr = []
        with open(file_list) as my_file:
            for line in my_file:
                line = line.strip()
                arr.append(line)

        lines = len(arr)
        try:
            lines = len(arr)
            while chunk > 0 and start_line <= (start_line + 5) \
                and start_line <= lines:
                print(arr[start_line])
                start_line = start_line - 1
                chunk = chunk - 1
                if arr[start_line] == arr[-1]:
                    input('\nClick Enter to Switch to Forward Parsing! ')
                    restart()                    
        except IndexError:
            return

    def runnerRev(stln):
        # This function actions based on the user input and will -
        # iterate the list of items ...
        #resetScreen()

        lines = []
        with open(file_list) as my_file:
            for line in my_file:
                line = line.strip()
                lines.append(line)
     
        i = int(stln)
        j = len(lines)
        
        while i <= j:
            #logo()
            os.system('tput smso')
            print(' ' * 28 + '<-  BACKWARD PARSING  <-' + ' ' * 29)
            os.system('tput rmso')
            listdisplayrev(i, 30)
            print()
            print('TOTAL ITEMS: ' + str(j) + ' '* 13 
                + current_time())
            highlight(' ' * 18 + 'PRESS ENTER TO PARSE ABOVE MENU, ? FOR HELP ' + ' ' * 18)
            response = input('Search > ')
            print()

            if re.search('^[\\\\*+-/. ]', response): restart()
            elif response == 'f':  resetScreen() ; runner(i)
            elif response == 'q':  exitProg()
            elif response == '?':  help() ; continue
            elif response == '' :  i = i - 1 ; resetScreen()
            elif not response   :  i = i + 1 ; resetScreen()

            elif re.search(r'^x[1-9]+', response):
                re_obj = re.compile(r'(x)(\d+)')
                mo = re_obj.search(response)
                item = mo.group(2)
                run_code(item)

            elif re.search(r'^e[1-9]+', response): 
                re_obj = re.compile(r'(e)(\d+)')
                mo = re_obj.search(response)
                item = mo.group(2)
                edit_function(item)
            
            elif re.match(r'^f[1-9]+', response):
                reObj = re.compile(r'(f)(\d+)')
                mo = reObj.search(response)
                item = mo.group(2)
                view_function(item)

            elif response.isnumeric(): 
                if int(response) <= lastItem(): 
                    resetScreen()
                    runnerRev(response)
                    restart()
                    # break
                else:
                    input('Not in the range of the list!\n' + 
                        '\nPress any key to  continue ..')
                    resetScreen()
                    continue                    
            else:
                try:
                    search_view(response)
                    print('')
                    return
                except Exception:
                    resetScreen()
                    continue
        return

    def runner(stln):
        # This function actions based on the user input and will -
        # iterate the list of items ...

        lines = []
        with open(file_list) as my_file:
            for line in my_file:
                line = line.strip()
                lines.append(line)

        i = int(stln)
        j = len(lines)
     
        while i <= j:
            #logo()
            os.system("tput smso");
            print(' ' * 28 + '->  FORWARD PARSING  ->' + ' ' * 29)
            os.system("tput rmso");
            listdisplay(i, 30)
            print()
            print('TOTAL ITEMS: ' + str(j) + ' ' * 50 
                + current_time())
            highlight(' ' * 18 + 'PRESS ENTER TO PARSE ABOVE MENU, ? FOR HELP ' + ' ' * 18)
            response = input('Search > ')
            print()
            
            if re.search('^[\\\\*+-/. ]', response): restart()

            elif response == 'r': resetScreen(); runnerRev(i)
            elif response == 'q': exitProg()
            elif response == '?': help(); continue
            elif response == '': i = i + 1  ; resetScreen() 
            elif not response: i = i + 1  ; resetScreen()

            elif response == 'bookmarks':
                os.system('\\vi + bookmarks')
                restart()
            
            elif response == 'b':
                resetScreen()
                os.system('cat bookmarks')
                input('Press any key to continue ..')
                restart()
                
            elif response == 'runme':
                os.system('\\vi runme.py')
                restart()

            elif response == 'openlist':
                os.system('\\vi ' + file_list )
                restart()

            elif re.search('^x[1-9]+', response):
                re_obj = re.compile(r'(x)(\d+)')
                mo = re_obj.search(response)
                item = mo.group(2)
                run_code(item)

            elif re.search('^e[1-9]+', response): 
                re_obj = re.compile(r'(e)(\d+)')
                mo = re_obj.search(response)
                item = mo.group(2)
                edit_function(item)
                    
            elif re.match('^f[1-9]+', response):
                reObj = re.compile(r'(f)(\d+)')
                mo = reObj.search(response)
                item = mo.group(2)
                view_function(item)

            elif response.isnumeric():
                if int(response) <= lastItem():
                    resetScreen()
                    runner(response)
                    restart()
                else:
                    input('Not in the range of the list!\n' + 
                        '\nPress any key to  continue ..')
                    resetScreen()
                    continue                    
            else:
                try:
                    search_view(response)
                    resetScreen()
                except Exception:
                    resetScreen()
                    continue

        return
    runner(1)

while True:
    resetScreen()
    logo()
    rolling_list()
